<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="node_modules/xterm/css/xterm.css" />
    <script src="node_modules/xterm/lib/xterm.js"></script>
    <title>Document</title>
</head>

<body>
    <div id="terminal" style="height: 95vh;"></div>
    <script>
        // 暗色主题
        Solarized_Darcula = {
            foreground: '#d2d8d9',
            background: '#3d3f41',
            cursor: '#d0d0d0',

            black: '#25292a',
            brightBlack: '#25292a',

            red: '#f24840',
            brightRed: '#f24840',

            green: '#629655',
            brightGreen: '#629655',

            yellow: '#b68800',
            brightYellow: '#b68800',

            blue: '#2075c7',
            brightBlue: '#2075c7',

            magenta: '#797fd4',
            brightMagenta: '#797fd4',

            cyan: '#15968d',
            brightCyan: '#15968d',

            white: '#d2d8d9',
            brightWhite: '#d2d8d9'
        }
        // 浅色主题
        GitHub = {
            foreground: '#3e3e3e',
            background: '#f4f4f4',
            cursor: '#3f3f3f',

            black: '#3e3e3e',
            brightBlack: '#666666',

            red: '#970b16',
            brightRed: '#de0000',

            green: '#07962a',
            brightGreen: '#87d5a2',

            yellow: '#f8eec7',
            brightYellow: '#f1d007',

            blue: '#003e8a',
            brightBlue: '#2e6cba',

            magenta: '#e94691',
            brightMagenta: '#ffa29f',

            cyan: '#89d1ec',
            brightCyan: '#1cfafe',

            white: '#ffffff',
            brightWhite: '#ffffff'
        }

        var term = new Terminal({
            theme: Solarized_Darcula,
            fontSize: 13,
        });
        term.open(document.getElementById('terminal'));

        // 调整窗口
        const fitSize = () => {
            const MINIMUM_COLS = 2;
            const MINIMUM_ROWS = 1;
            const core = term._core;
            const dims = core._renderService.dimensions;

            if (dims.css.cell.width === 0 || dims.css.cell.height === 0) {
                return undefined;
            }

            const scrollbarWidth = term.options.scrollback === 0 ? 0 : core.viewport.scrollBarWidth;
            const parentElementStyle = window.getComputedStyle(term.element.parentElement);
            const parentElementHeight = parseInt(parentElementStyle.getPropertyValue('height'));
            const parentElementWidth = Math.max(0, parseInt(parentElementStyle.getPropertyValue('width')));
            const elementStyle = window.getComputedStyle(term.element);
            const elementPadding = {
                top: parseInt(elementStyle.getPropertyValue('padding-top')),
                bottom: parseInt(elementStyle.getPropertyValue('padding-bottom')),
                right: parseInt(elementStyle.getPropertyValue('padding-right')),
                left: parseInt(elementStyle.getPropertyValue('padding-left'))
            };
            const elementPaddingVer = elementPadding.top + elementPadding.bottom;
            const elementPaddingHor = elementPadding.right + elementPadding.left;
            const availableHeight = parentElementHeight - elementPaddingVer;
            const availableWidth = parentElementWidth - elementPaddingHor - scrollbarWidth;
            const geometry = {
                cols: Math.max(MINIMUM_COLS, Math.floor(availableWidth / dims.css.cell.width)),
                rows: Math.max(MINIMUM_ROWS, Math.floor(availableHeight / dims.css.cell.height))
            };
            console.log(geometry)
            term.resize(geometry.cols, geometry.rows)
            socket.send(JSON.stringify({ command: "resize", params: { width: geometry.cols, heigh: geometry.rows } }))
        }
        // 终端大小调整
        window.onresize = fitSize

        let socket = new WebSocket("ws://127.0.0.1:8090/mpaas/api/v1/tasks/xxxx/debug");
        socket.onopen = function (e) {
            term.write("[open] Connection established\r\n");
            term.write("Sending to server\r\n");
            socket.send(JSON.stringify({ task_id: "task-ci85q2ro99m31pv5pho0", container_name: "build-and-push" }));
            fitSize()
        };
        socket.onmessage = function (event) {
            if (event.data instanceof Blob) {
                // 数据
                let reader = new FileReader();
                reader.onload = e => {
                    term.write(e.target.result)
                };
                reader.readAsText(event.data)
            } else {
                // 指令响应
                console.log(event.data)
            }
        };
        socket.onclose = function (event) {
            if (event.wasClean) {
                term.write(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
            } else {
                // e.g. server process killed or network down
                // event.code is usually 1006 in this case
                term.write('[close] Connection died');
            }
        };
        socket.onerror = function (error) {
            term.write(`[error]`);
        };

        // 终端设置
        term.onData(send => {
            // 数据都使用bytes
            const encoder = new TextEncoder();
            const arrayBuffer = encoder.encode(send).buffer;
            socket.send(arrayBuffer)
        })
    </script>
</body>

</html>